// settings & const
const DEFAULT_HEADERS = {
    "Content-Type": "application/json",
};
export default function createClient(clientOptions = {}) {
    const { fetch: baseFetch = globalThis.fetch, querySerializer: globalQuerySerializer, bodySerializer: globalBodySerializer, ...options } = clientOptions;
    let baseUrl = options.baseUrl ?? "";
    if (baseUrl.endsWith("/")) {
        baseUrl = baseUrl.slice(0, -1); // remove trailing slash
    }
    async function coreFetch(url, fetchOptions) {
        const { fetch = baseFetch, headers, body: requestBody, params = {}, parseAs = "json", querySerializer = globalQuerySerializer ?? defaultQuerySerializer, bodySerializer = globalBodySerializer ?? defaultBodySerializer, ...init } = fetchOptions || {};
        // URL
        const finalURL = createFinalURL(url, {
            baseUrl,
            params,
            querySerializer,
        });
        const finalHeaders = mergeHeaders(DEFAULT_HEADERS, clientOptions?.headers, headers, params.header);
        // fetch!
        const requestInit = {
            redirect: "follow",
            ...options,
            ...init,
            headers: finalHeaders,
        };
        if (requestBody) {
            requestInit.body = bodySerializer(requestBody);
        }
        // remove `Content-Type` if serialized body is FormData; browser will correctly set Content-Type & boundary expression
        if (requestInit.body instanceof FormData) {
            finalHeaders.delete("Content-Type");
        }
        const response = await fetch(finalURL, requestInit);
        // handle empty content
        // note: we return `{}` because we want user truthy checks for `.data` or `.error` to succeed
        if (response.status === 204 ||
            response.headers.get("Content-Length") === "0") {
            return response.ok
                ? { data: {}, response: response }
                : { error: {}, response: response };
        }
        // parse response (falling back to .text() when necessary)
        if (response.ok) {
            let data; // we have to leave this empty here so that we don't consume the body
            if (parseAs !== "stream") {
                const cloned = response.clone();
                data =
                    typeof cloned[parseAs] === "function"
                        ? await cloned[parseAs]()
                        : await cloned.text();
            }
            else {
                // bun consumes the body when calling response.body, therefore we need to clone the response before accessing it
                data = response.clone().body;
            }
            return { data, response: response };
        }
        // handle errors (always parse as .json() or .text())
        let error = {};
        try {
            error = await response.clone().json();
        }
        catch {
            error = await response.clone().text();
        }
        return { error, response: response };
    }
    return {
        /** Call a GET endpoint */
        async GET(url, ...init) {
            return coreFetch(url, { ...init[0], method: "GET" });
        },
        /** Call a PUT endpoint */
        async PUT(url, ...init) {
            return coreFetch(url, { ...init[0], method: "PUT" });
        },
        /** Call a POST endpoint */
        async POST(url, ...init) {
            return coreFetch(url, { ...init[0], method: "POST" });
        },
        /** Call a DELETE endpoint */
        async DELETE(url, ...init) {
            return coreFetch(url, {
                ...init[0],
                method: "DELETE",
            });
        },
        /** Call a OPTIONS endpoint */
        async OPTIONS(url, ...init) {
            return coreFetch(url, {
                ...init[0],
                method: "OPTIONS",
            });
        },
        /** Call a HEAD endpoint */
        async HEAD(url, ...init) {
            return coreFetch(url, { ...init[0], method: "HEAD" });
        },
        /** Call a PATCH endpoint */
        async PATCH(url, ...init) {
            return coreFetch(url, { ...init[0], method: "PATCH" });
        },
        /** Call a TRACE endpoint */
        async TRACE(url, ...init) {
            return coreFetch(url, { ...init[0], method: "TRACE" });
        },
    };
}
// utils
/** serialize query params to string */
export function defaultQuerySerializer(q) {
    const search = [];
    if (q && typeof q === "object") {
        for (const [k, v] of Object.entries(q)) {
            const value = defaultQueryParamSerializer([k], v);
            if (value) {
                search.push(value);
            }
        }
    }
    return search.join("&");
}
/** serialize different query param schema types to a string */
export function defaultQueryParamSerializer(key, value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return `${deepObjectPath(key)}=${encodeURIComponent(value)}`;
    }
    if (typeof value === "number" || typeof value === "boolean") {
        return `${deepObjectPath(key)}=${String(value)}`;
    }
    if (Array.isArray(value)) {
        if (!value.length) {
            return undefined;
        }
        const nextValue = [];
        for (const item of value) {
            const next = defaultQueryParamSerializer(key, item);
            if (next !== undefined) {
                nextValue.push(next);
            }
        }
        return nextValue.join(`&`);
    }
    if (typeof value === "object") {
        if (!Object.keys(value).length) {
            return undefined;
        }
        const nextValue = [];
        for (const [k, v] of Object.entries(value)) {
            if (v !== undefined && v !== null) {
                const next = defaultQueryParamSerializer([...key, k], v);
                if (next !== undefined) {
                    nextValue.push(next);
                }
            }
        }
        return nextValue.join("&");
    }
    return encodeURIComponent(`${deepObjectPath(key)}=${String(value)}`);
}
/** flatten a node path into a deepObject string */
function deepObjectPath(path) {
    let output = path[0];
    for (const k of path.slice(1)) {
        output += `[${k}]`;
    }
    return output;
}
/** serialize body object to string */
export function defaultBodySerializer(body) {
    return JSON.stringify(body);
}
/** Construct URL string from baseUrl and handle path and query params */
export function createFinalURL(pathname, options) {
    let finalURL = `${options.baseUrl}${pathname}`;
    if (options.params.path) {
        for (const [k, v] of Object.entries(options.params.path)) {
            finalURL = finalURL.replace(`{${k}}`, encodeURIComponent(String(v)));
        }
    }
    const search = options.querySerializer(options.params.query ?? {});
    if (search) {
        finalURL += `?${search}`;
    }
    return finalURL;
}
/** merge headers a and b, with b taking priority */
export function mergeHeaders(...allHeaders) {
    const headers = new Headers();
    for (const headerSet of allHeaders) {
        if (!headerSet || typeof headerSet !== "object") {
            continue;
        }
        const iterator = headerSet instanceof Headers
            ? // @ts-expect-error Headers definitely have entries()
                headerSet.entries()
            : Object.entries(headerSet);
        for (const [k, v] of iterator) {
            if (v === null) {
                headers.delete(k);
            }
            else if (v !== undefined) {
                headers.set(k, v);
            }
        }
    }
    return headers;
}
